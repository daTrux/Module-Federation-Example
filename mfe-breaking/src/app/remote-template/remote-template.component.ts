import { ChangeDetectorRef, Component, ElementRef, Inject, OnInit } from '@angular/core';
import { CoreUiMessage, CoreUiSdk, RemoteChildren } from '@fts/coreui-sdk';

@Component({
  selector: 'app-remote-template',
  templateUrl: './remote-template.component.html',
  styleUrls: ['./remote-template.component.scss']
})
export class RemoteTemplateComponent implements OnInit {

  private ftsProps: any;
  public mfeUniqueId = '';
  public receivedMessage = '';
  public title = $localize`Your Remote Template Works!`;
  // To create a new CoreUiSdk instance every time the component is instantiated
  private readonly coreUiSdk: CoreUiSdk = new CoreUiSdk();

  constructor(private elementRef: ElementRef,
              private cdr: ChangeDetectorRef) {
  }

  ngOnInit(): void {
    this.ftsProps = this.elementRef.nativeElement.__ftsProps__
      || {channelName: 'remote-template-VuQxxHbO7lRZpe9-hunAe'};
    this.mfeUniqueId = this.ftsProps.channelName;

    // Provide as arguments:
    //  - the channel name generated by the Coreui Shell,
    //  - a callback function for PubSub message handling and
    //  - an optional callback function for Direct message handling
    this.coreUiSdk.init(this.mfeUniqueId, this.genericHandleMessage.bind(this), this.genericDirectHandleMessage.bind(this));
  }

  genericHandleMessage(message: CoreUiMessage): void {

    this.receivedMessage = JSON.stringify(message, null, 2);
    this.cdr.detectChanges();

    // Add your generic logic to handle message received (e.g. broadcast message)

  }

  genericDirectHandleMessage(message: CoreUiMessage): Promise<CoreUiMessage | void> {

    // Add your generic logic to handle direct message received

    this.receivedMessage = JSON.stringify(message, null, 2);
    this.cdr.detectChanges();

    return new Promise<CoreUiMessage | void>(res => {
      res({
        ...message,
        payload: 'response',
        isResponse: true
      } as CoreUiMessage);
    });
  }

  // Utils method to retrieve remote children (remotes that specify as loader our elementName) and load/initialize them.
  // Please adjust or remove if you don't need to configure a remote-shell microfrontend.
  initRemoteChildren(): void {
    this.coreUiSdk.getRemoteChildren()
      .then(({microFrontends, logic}: RemoteChildren) => {
        return {
          microFrontends: Promise.all(microFrontends.map(mf => {
            // initChildMicroFrontend API:
            //  - tells the shell to open a channel of communication for the child microfrontend
            //  - loads the child microfrontend module
            //  - creates the HTMLFTSElement specified by the child elementName
            // It's up to the parent append where needed the returned child element
            return this.coreUiSdk.initChildMicroFrontend(mf, { /* optional data to provide to the child during initialization */})
              .catch(() => 'initChildMicroFrontend failed!' as any);
          })),
          logic: Promise.all(logic.map(l => {
            // initChildLogic API:
            //  - tells the shell to open a channel of communication for the child logic
            //  - loads the child logic module
            //  - executes the exported logic
            return this.coreUiSdk.initChildLogic(l, { /* optional data to provide to the child during initialization */})
              .catch(() => 'initChildLogic failed!' as any);
          }))
        };
      });
  }

}
